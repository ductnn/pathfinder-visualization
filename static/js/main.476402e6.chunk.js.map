{"version":3,"sources":["models/node.ts","models/grid.ts","components/animations.ts","components/Node.tsx","components/Grid.tsx","style/globalStyle.ts","store/UI.ts","algorithms/dijkstra.ts","algorithms/astar.ts","algorithms/breadthFirstSearch.ts","algorithms/depthFirstSearch.ts","algorithms/greedyBestFirst.ts","utils/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["AnimationType","Node","types","model","id","identifier","x","number","y","isStart","boolean","isEnd","prevNode","maybe","reference","late","volatile","self","observable","animate","undefined","isWall","isVisited","distance","Infinity","f","views","heuristic","finishNode","Math","abs","actions","clear","toggleWall","setIsVisited","setAnimate","animation","setPreviousNode","incrementDistance","NB_ITEM_PER_ROWS","window","screen","width","GridModel","nodes","array","find","getUnvisitedNodes","chain","reject","node","value","getNodeNeighbours","topIndex","rightIndex","bottomIndex","leftIndex","floor","compact","getShortestPath","afterCreate","nodeIndices","range","startNodeIndex","sample","endNodeIndex","slice","forEach","index","push","create","clean","animatePathNodes","keyframes","animateVisitedNodes","NodeCell","styled","div","isUndefined","css","getAnimationName","console","log","VISITED_NODES","PATH","observer","onMouseDown","onMouseEnter","event","buttons","GridContainer","RowContainer","Grid","grid","nodeChunks","chunk","renderNode","key","map","row","rowIdx","State","Algo","GlobalStyle","createGlobalStyle","dijkstra","startNode","unvisitedNeighbours","visitedNodes","currentNode","orderBy","shift","unvisitedNode","isEmpty","astar","minBy","neighbour","some","breadthFirstSearch","pop","depthFirstSearch","greedyBestFirst","neighbours","uiStore","state","algo","DIJKSTRA","generateGrid","markStart","START","markFinish","FINISHED","changeAlgo","clearBoard","sleep","timeout","Promise","resolve","setTimeout","asyncForEach","callback","a","length","App","getAlgo","ASTAR","GREEDY","DEPTH","BREADTH","handleClick","algoFunction","endNode","shortestPath","Fragment","onClick","onChange","target","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.476402e6.chunk.js","sourcesContent":["import { observable } from \"mobx\";\nimport { types, Instance, IAnyModelType } from \"mobx-state-tree\";\n\nexport enum AnimationType {\n  VISITED_NODES,\n  PATH\n}\n\ninterface IVolatile {\n  animate?: AnimationType;\n  isWall: boolean;\n  isVisited: boolean;\n  distance: number;\n  f: number;\n}\n\nexport const Node = types\n  .model(\"Node\", {\n    id: types.identifier,\n    x: types.number,\n    y: types.number,\n    isStart: types.boolean,\n    isEnd: types.boolean,\n    prevNode: types.maybe(\n      types.reference(types.late((): IAnyModelType => Node))\n    )\n  })\n  .volatile(self =>\n    observable<IVolatile>({\n      animate: undefined,\n      isWall: false,\n      isVisited: false,\n      distance: self.isStart ? 0 : Infinity,\n      f: 0\n    })\n  )\n  .views(self => ({\n    heuristic(finishNode: INode): number {\n      return Math.abs(self.x - finishNode.x) + Math.abs(self.y - finishNode.y);\n    }\n  }))\n  .actions(self => {\n    const actions = {\n      clear() {\n        self.isVisited = false;\n        self.animate = undefined;\n        self.distance = self.isStart ? 0 : Infinity;\n        self.f = 0;\n      },\n      toggleWall() {\n        if (self.isStart || self.isEnd || self.isVisited) {\n          return;\n        }\n\n        self.isWall = !self.isWall;\n      },\n\n      setIsVisited() {\n        if (self.isStart || self.isEnd || self.isWall) {\n          return;\n        }\n\n        self.isVisited = true;\n      },\n\n      setAnimate(animation: AnimationType) {\n        self.animate = animation;\n      },\n\n      setPreviousNode(prevNode: INode) {\n        self.prevNode = prevNode;\n      },\n\n      incrementDistance(prevNode: INode, finishNode?: INode) {\n        if (prevNode.distance + 1 < self.distance) {\n          actions.setPreviousNode(prevNode);\n          self.distance = prevNode.distance + 1;\n\n          if (finishNode) {\n            self.f = self.distance + self.heuristic(finishNode);\n          }\n        }\n      }\n    };\n\n    return actions;\n  });\n\nexport interface INode extends Instance<typeof Node> {}\n","import { types, Instance } from \"mobx-state-tree\";\nimport { range, sample, chain, find, compact } from \"lodash\";\n\nimport { Node, INode } from \"./node\";\n\nexport const NB_ROWS = 25;\nexport const NB_ITEM_PER_ROWS = window.screen.width / 32;\n\nexport const GridModel = types\n  .model(\"Grid\", {\n    nodes: types.array(Node)\n  })\n  .views(self => {\n    const views = {\n      get startNode() {\n        return find(self.nodes, { isStart: true }) as INode;\n      },\n      get endNode() {\n        return find(self.nodes, { isEnd: true }) as INode;\n      },\n      getUnvisitedNodes() {\n        return chain(self.nodes)\n          .reject(node => node.isVisited || node.isWall)\n          .value();\n      },\n      getNodeNeighbours(node: INode) {\n        const topIndex = node.x + (node.y - 1) * NB_ITEM_PER_ROWS;\n        const rightIndex = node.x + 1 + node.y * NB_ITEM_PER_ROWS;\n        const bottomIndex = node.x + (node.y + 1) * NB_ITEM_PER_ROWS;\n        const leftIndex = node.x - 1 + node.y * NB_ITEM_PER_ROWS;\n\n        // Diagonals\n        // const topRightIndex = node.x + 1 + (node.y - 1) * NB_ITEM_PER_ROWS;\n        // const bottomRightIndex = node.x + 1 + (node.y + 1) * NB_ITEM_PER_ROWS;\n        // const bottomLeftIndex = node.x - 1 + (node.y + 1) * NB_ITEM_PER_ROWS;\n        // const topLeftIndex = node.x - 1 + (node.y - 1) * NB_ITEM_PER_ROWS;\n\n        return chain([\n          topIndex > 0 && self.nodes[topIndex], // TOP\n          // topRightIndex > 0 &&\n          //   Math.floor(topRightIndex / NB_ITEM_PER_ROWS) === node.y - 1 &&\n          //   self.nodes[topRightIndex], // TOP RIGHT\n          Math.floor(rightIndex / NB_ITEM_PER_ROWS) === node.y &&\n            self.nodes[rightIndex], // RIGHT\n\n          // bottomRightIndex < NB_ROWS * NB_ITEM_PER_ROWS &&\n          //   Math.floor(bottomRightIndex / NB_ITEM_PER_ROWS) === node.y + 1 &&\n          //   self.nodes[bottomRightIndex], // BOTTOM RIGHT\n          bottomIndex < NB_ROWS * NB_ITEM_PER_ROWS && self.nodes[bottomIndex], // BOTTOM\n          // bottomLeftIndex < NB_ROWS * NB_ITEM_PER_ROWS &&\n          //   Math.floor(bottomLeftIndex / NB_ITEM_PER_ROWS) === node.y + 1 &&\n          //   self.nodes[bottomLeftIndex], // BOTTOM LEFT\n\n          Math.floor(leftIndex / NB_ITEM_PER_ROWS) === node.y &&\n            self.nodes[leftIndex] // LEFT\n          // topLeftIndex > 0 &&\n          //   Math.floor(topLeftIndex / NB_ITEM_PER_ROWS) === node.y - 1 &&\n          //   self.nodes[topLeftIndex] // BOTTOM LEFT\n        ])\n          .compact()\n          .reject(node => node.isVisited || node.isWall || node.isStart)\n          .value();\n      },\n      getShortestPath(node: INode): INode[] {\n        if (!node || !node.prevNode) {\n          return [];\n        }\n\n        return compact([...views.getShortestPath(node.prevNode), node]);\n      }\n    };\n\n    return views;\n  })\n  .actions(self => ({\n    afterCreate() {\n      const nodeIndices = range(NB_ITEM_PER_ROWS * NB_ROWS);\n      // Randomly choose the start and end node\n      const startNodeIndex = sample(nodeIndices) as number;\n      const endNodeIndex = sample([\n        ...nodeIndices.slice(0, startNodeIndex),\n        ...nodeIndices.slice(startNodeIndex + 1)\n      ]);\n\n      nodeIndices.forEach(index => {\n        const x = index % NB_ITEM_PER_ROWS;\n        const y = Math.floor(index / NB_ITEM_PER_ROWS);\n        self.nodes.push(\n          Node.create({\n            id: `${x}+${y}`,\n            x,\n            y,\n            isStart: index === startNodeIndex,\n            isEnd: index === endNodeIndex\n          })\n        );\n      });\n    },\n    clean() {\n      self.nodes.forEach(node => {\n        node.clear();\n      });\n    }\n  }));\n\nexport interface IGrid extends Instance<typeof GridModel> {}\n","import { keyframes } from \"styled-components\";\n\nexport const animatePathNodes = keyframes`\n  0% {\n    opacity: 0;\n    background-color: #9DE3AD;\n  }\n\n  100% {\n    opacity: 1;\n    background-color: #F8FFAE;\n  }\n`;\n\nexport const animateVisitedNodes = keyframes`\n  0% {\n    opacity: 0;\n    background-color: rgba(0, 0, 66, 0.75);\n  }\n\n  100% {\n    opacity: 1;\n    background-color: rgba(0, 190, 218, 0.75);\n  }\n`;\n","import React from \"react\";\nimport styled, { css } from \"styled-components\";\nimport { observer } from \"mobx-react\";\nimport { isUndefined } from \"lodash\";\n\nimport { INode, AnimationType } from \"../models/node\";\nimport { IGrid } from \"../models/grid\";\nimport { animatePathNodes, animateVisitedNodes } from \"./animations\";\n\ninterface IProps {\n  node: INode;\n  grid: IGrid;\n}\n\ninterface INodeCellProps {\n  isStart: boolean;\n  isEnd: boolean;\n  isWall: boolean;\n  isVisited: boolean;\n  animate?: AnimationType;\n}\n\nconst NodeCell = styled.div<INodeCellProps>`\n  width: 32px;\n  height: 32px;\n  outline: 1px solid #A3D5FF;\n  background-color: white;\n  user-select: none;\n  position: relative;\n\n  ${({ isWall }) => isWall && `background-color: #071E22;`}\n  ${({ isStart }) => isStart && `background-color: #736CED;`}\n  ${({ isEnd }) => isEnd && `background-color: #E15554;`}\n  ${({ isVisited, animate }) => {\n    if (!isVisited) {\n      return;\n    }\n\n    if (!isUndefined(animate)) {\n      return css`\n        :after {\n          position: relative;\n          left: 0;\n          top: 0;\n          display: block;\n          content: \" \";\n          height: 100%;\n          width: 100%;\n\n          animation-name: ${getAnimationName(animate)};\n          animation-duration: 1000ms;\n          animation-delay: 0;\n          animation-direction: alternate;\n          animation-iteration-count: 1;\n          animation-fill-mode: forwards;\n          animation-play-state: running;\n        }\n      `;\n    }\n  }}\n`;\n\nconst getAnimationName = (animate: AnimationType) => {\n  console.log(\n    \"animate\",\n    animate,\n    AnimationType.VISITED_NODES,\n    AnimationType.PATH\n  );\n  console.log(\n    \"animate === AnimationType.VISITED_NODES\",\n    animate === AnimationType.VISITED_NODES\n  );\n  if (animate === AnimationType.VISITED_NODES) {\n    return animateVisitedNodes;\n  }\n\n  return animatePathNodes;\n};\n\nexport const Node: React.FC<IProps> = observer(({ node }) => {\n  console.log(\"node.animate\", node.animate);\n  console.log(\"node.isVisited\", node.isVisited);\n  return (\n    <NodeCell\n      onMouseDown={node.toggleWall}\n      isStart={node.isStart}\n      isEnd={node.isEnd}\n      isWall={node.isWall}\n      isVisited={node.isVisited}\n      animate={node.animate}\n      onMouseEnter={event => {\n        if (event.buttons === 1) {\n          node.toggleWall();\n        }\n      }}\n    />\n  );\n});\n","import React from \"react\";\nimport { chunk } from \"lodash\";\nimport styled from \"styled-components\";\n\nimport { NB_ITEM_PER_ROWS, IGrid } from \"../models/grid\";\nimport { INode } from \"../models/node\";\n\nimport { Node } from \"./Node\";\n\nconst GridContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n`;\n\nconst RowContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n`;\n\ninterface IProps {\n  grid: IGrid;\n}\n\nexport const Grid: React.FC<IProps> = ({ grid }) => {\n  const nodeChunks = chunk(grid.nodes, NB_ITEM_PER_ROWS);\n\n  const renderRow = (row: INode[], rowIdx: number) => {\n    return (\n      <RowContainer key={rowIdx}>\n        {row.map(node => renderNode(node))}\n      </RowContainer>\n    );\n  };\n\n  const renderNode = (node: INode) => {\n    return <Node key={node.x + node.y} node={node} grid={grid} />;\n  };\n\n  return <GridContainer>{nodeChunks.map(renderRow)}</GridContainer>;\n};\n","import { createGlobalStyle } from \"styled-components\";\n\nexport const GlobalStyle = createGlobalStyle`\n  html, body, #root {\n    height: 100%;\n    overflow: hidden;\n  }\n`;\n","import { types, Instance } from \"mobx-state-tree\";\n\nimport { GridModel } from \"../models/grid\";\nimport { observable } from \"mobx\";\n\nenum State {\n  START,\n  FINISHED\n}\n\nexport enum Algo {\n  DIJKSTRA,\n  ASTAR,\n  GREEDY,\n  DEPTH,\n  BREADTH\n}\ninterface IVolatile {\n  state?: State;\n  algo?: Algo;\n}\n\nconst UIStore = types\n  .model(\"UIStore\", {\n    grid: types.maybe(GridModel)\n  })\n  .volatile(() =>\n    observable<IVolatile>({\n      state: undefined,\n      algo: Algo.DIJKSTRA\n    })\n  )\n  .actions(self => {\n    const actions = {\n      afterCreate() {\n        actions.generateGrid();\n      },\n      generateGrid() {\n        self.grid = GridModel.create();\n      },\n      markStart() {\n        self.state = State.START;\n      },\n      markFinish() {\n        self.state = State.FINISHED;\n      },\n      changeAlgo(algo: Algo) {\n        self.algo = algo;\n      },\n      clearBoard() {\n        if (self.grid) {\n          self.grid.clean();\n        }\n      }\n    };\n\n    return actions;\n  });\n\nexport const uiStore = UIStore.create();\n\nexport interface IUIStore extends Instance<typeof UIStore> {}\n","import { isEmpty, orderBy } from \"lodash\";\n\nimport { INode } from \"../models/node\";\nimport { IGrid } from \"../models/grid\";\n\nexport const dijkstra = (grid: IGrid, startNode: INode, finishNode: INode) => {\n  let unvisitedNeighbours = grid.getUnvisitedNodes();\n  let visitedNodes = [];\n\n  while (!isEmpty(unvisitedNeighbours)) {\n    unvisitedNeighbours = orderBy(unvisitedNeighbours, [\"distance\"], [\"asc\"]);\n    const currentNode = unvisitedNeighbours.shift() as INode;\n\n    if (currentNode.distance === Infinity) {\n      return visitedNodes;\n    }\n\n    if (currentNode.id === finishNode.id) {\n      return visitedNodes;\n    }\n\n    grid.getNodeNeighbours(currentNode).forEach(unvisitedNode => {\n      unvisitedNode.incrementDistance(currentNode);\n    });\n    currentNode.setIsVisited();\n    visitedNodes.push(currentNode);\n  }\n\n  return visitedNodes;\n};\n","import { isEmpty, minBy, reject, some } from \"lodash\";\n\nimport { INode } from \"../models/node\";\nimport { IGrid } from \"../models/grid\";\n\nexport const astar = (grid: IGrid, startNode: INode, finishNode: INode) => {\n  let unvisitedNeighbours = [startNode];\n  let visitedNodes: INode[] = [];\n\n  while (!isEmpty(unvisitedNeighbours)) {\n    const currentNode = minBy(unvisitedNeighbours, \"f\") as INode;\n\n    if (currentNode.id === finishNode.id) {\n      return visitedNodes;\n    }\n\n    unvisitedNeighbours = reject(unvisitedNeighbours, { id: currentNode.id });\n    currentNode.setIsVisited();\n    visitedNodes.push(currentNode);\n\n    const neighbours = grid.getNodeNeighbours(currentNode);\n\n    // eslint-disable-next-line\n    neighbours.forEach(neighbour => {\n      if (some(visitedNodes, { id: neighbour.id })) {\n        return;\n      }\n\n      neighbour.incrementDistance(currentNode, finishNode);\n\n      if (!some(unvisitedNeighbours, { id: neighbour.id })) {\n        unvisitedNeighbours.push(neighbour);\n      }\n    });\n  }\n\n  return visitedNodes;\n};\n","import { isEmpty } from \"lodash\";\n\nimport { INode } from \"../models/node\";\nimport { IGrid } from \"../models/grid\";\n\nexport const breadthFirstSearch = (\n  grid: IGrid,\n  startNode: INode,\n  finishNode: INode\n) => {\n  let unvisitedNeighbours = [startNode];\n  let visitedNodes = [];\n  startNode.setIsVisited();\n\n  while (!isEmpty(unvisitedNeighbours)) {\n    const currentNode = unvisitedNeighbours.pop() as INode;\n\n    visitedNodes.push(currentNode);\n\n    if (currentNode.id === finishNode.id) {\n      return visitedNodes;\n    }\n\n    const neighbours = grid.getNodeNeighbours(currentNode);\n\n    neighbours.forEach(neighbour => {\n      neighbour.setPreviousNode(currentNode);\n      neighbour.setIsVisited();\n      unvisitedNeighbours.push(neighbour);\n    });\n  }\n\n  return visitedNodes;\n};\n","import { isEmpty } from \"lodash\";\n\nimport { INode } from \"../models/node\";\nimport { IGrid } from \"../models/grid\";\n\nexport const depthFirstSearch = (\n  grid: IGrid,\n  startNode: INode,\n  finishNode: INode\n) => {\n  let unvisitedNeighbours = [startNode];\n  let visitedNodes = [];\n\n  while (!isEmpty(unvisitedNeighbours)) {\n    const currentNode = unvisitedNeighbours.shift() as INode;\n    if (currentNode.id === finishNode.id) {\n      return visitedNodes;\n    }\n\n    if (currentNode.isVisited) {\n      continue;\n    }\n\n    currentNode.setIsVisited();\n    visitedNodes.push(currentNode);\n\n    const neighbours = grid.getNodeNeighbours(currentNode);\n\n    neighbours.forEach(neighbour => {\n      neighbour.setPreviousNode(currentNode);\n      unvisitedNeighbours.push(neighbour);\n    });\n  }\n\n  return visitedNodes;\n};\n","import { isEmpty, minBy, reject, some, chain } from \"lodash\";\n\nimport { INode } from \"../models/node\";\nimport { IGrid } from \"../models/grid\";\n\nexport const greedyBestFirst = (\n  grid: IGrid,\n  startNode: INode,\n  finishNode: INode\n) => {\n  let unvisitedNeighbours = [startNode];\n  let visitedNodes: INode[] = [];\n\n  while (!isEmpty(unvisitedNeighbours)) {\n    const currentNode = minBy(unvisitedNeighbours, \"f\") as INode;\n\n    if (currentNode.id === finishNode.id) {\n      return visitedNodes;\n    }\n\n    unvisitedNeighbours = reject(unvisitedNeighbours, { id: currentNode.id });\n    currentNode.setIsVisited();\n    visitedNodes.push(currentNode);\n\n    const neighbours = grid.getNodeNeighbours(currentNode);\n\n    chain(neighbours)\n      .orderBy([node => node.heuristic(finishNode)], [\"asc\"])\n      // eslint-disable-next-line\n      .forEach(neighbour => {\n        if (some(visitedNodes, { id: neighbour.id })) {\n          return;\n        }\n\n        neighbour.incrementDistance(currentNode, finishNode);\n\n        if (!some(unvisitedNeighbours, { id: neighbour.id })) {\n          unvisitedNeighbours.push(neighbour);\n        }\n      })\n      .value();\n  }\n\n  return visitedNodes;\n};\n","export function sleep(timeout: any) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n\nexport async function asyncForEach(array: Array<any>, callback: Function) {\n  for (let index = 0; index < array.length; index++) {\n    await callback(array[index], index, array);\n  }\n}\n","import React from \"react\";\nimport { observer } from \"mobx-react\";\n\nimport { Grid } from \"./components/Grid\";\nimport { GlobalStyle } from \"./style/globalStyle\";\nimport {\n  dijkstra,\n  astar,\n  greedyBestFirst,\n  depthFirstSearch,\n  breadthFirstSearch\n} from \"./algorithms\";\nimport { AnimationType, INode } from \"./models/node\";\nimport { uiStore, Algo } from \"./store/UI\";\nimport { IGrid } from \"./models/grid\";\nimport { asyncForEach, sleep } from \"./utils\";\n\nconst App: React.FC = observer(() => {\n  const grid = uiStore.grid as IGrid;\n\n  const getAlgo = () => {\n    const algo = uiStore.algo as Algo;\n    switch (algo) {\n      case Algo.DIJKSTRA:\n        return dijkstra;\n      case Algo.ASTAR:\n        return astar;\n      case Algo.GREEDY:\n        return greedyBestFirst;\n      case Algo.DEPTH:\n        return depthFirstSearch;\n      case Algo.BREADTH:\n        return breadthFirstSearch;\n      default:\n        return dijkstra;\n    }\n  };\n\n  const handleClick = async () => {\n    const algoFunction = getAlgo();\n    const visitedNodes = algoFunction(grid, grid.startNode, grid.endNode);\n    const shortestPath = grid.getShortestPath(grid.endNode);\n\n    await asyncForEach(visitedNodes, async (node: INode) => {\n      await sleep(20);\n      node.setAnimate(AnimationType.VISITED_NODES);\n    });\n\n    await asyncForEach(shortestPath, async (node: INode) => {\n      await sleep(20);\n      node.setAnimate(AnimationType.PATH);\n    });\n  };\n\n  const handleChangeAlgo = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    uiStore.changeAlgo(+event.target.value);\n  };\n\n  return (\n    <React.Fragment>\n      <button onClick={handleClick}>Start Algo</button>\n      <button onClick={uiStore.generateGrid}>Generate Grid</button>\n      <select onChange={handleChangeAlgo} value={uiStore.algo}>\n        <option value={Algo.DIJKSTRA}>Dijsktra</option>\n        <option value={Algo.ASTAR}>A*</option>\n        <option value={Algo.GREEDY}>Greedy Best First</option>\n        <option value={Algo.DEPTH}>Depth Best First</option>\n        <option value={Algo.BREADTH}>Breadth Best First</option>\n      </select>\n      <button onClick={uiStore.clearBoard}>Clean Board</button>\n      <Grid grid={grid} />\n      <GlobalStyle />\n    </React.Fragment>\n  );\n});\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}